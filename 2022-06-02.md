# 클로저
--> 잘모르겠음
--> 클로저를 알려면 스코프 먼저 알아야한다고 했음!

## 스코프
- 범위라는 의미
- JavaScript에만 국한된 개념 x
- 식별자 접근 규칙에 따른 유효 범위
- 식별자(변수, 함수, 클래스)에 접근할 수 있는 범위 존재
- 범위는 중괄호나 함수에 의해 나눔
- Block Scope = 블록 스코프, Function Scope = 함수 스코프

## 스코프의 주요 규칙
- 1. 안쪽 스코프에서 바깥쪽 스코프로 접근 O, 반대는 X
- 2. 중첩 가능
- 3. 전역 스코프, 지역 스코프
-- 가장 바깥쪽 스코프 : 전역 스코프
-- 전역이 아닌 스코프 : 지역 스코프
- 4. 지역 변수는 전역 변수보다 우선순위가 높음
-- 전역 스코프에서 선언한 변수 -> 전역 변수
-- 지역 스코프에서 선언한 변수 -> 지역 변수
-- 지역 변수는 전역 변수보다 더 높은 우선 순위

## 스코프의 종류
- 화살표 함수는 함수 스코프 X -> 블록 스코프 O

## var, let, const
- const
-- 유효 범위 : 블록 스코프 / 함수 스코프
-- 값 재할당 : 불가능
-- 재선언 : 불가능

- let
-- 유효 범위 : 블록 스코프 / 함수 스코프
-- 값 재할당 : 가능
-- 재선언 : 불가능

- var
-- 유효 범위 : 함수 스코프
-- 값 재할당 : 가능
-- 재선언 : 가능

----------------------------------

for(let i=0; i<10; i++)  {
console.log(i);
}
// 전역스코프에서 선언한 변수 i 는 존재하지 않음으로 아래에서 ReferenceErrer을 일으킨다.
console.log(i); // ReferenceErrer

----------------------------------------------------------------------------

for(var i=0; i<10; i++)  {
console.log(i);
}
// var로 선언한 변수 i 는 지역 스코프에서 선언되었지만 모든 스코프에서 접근 가능하다.
console.log(i); // 9

-------------------------------------------------

- 블록 스코프 안에서 let과 const로 선언한 변수는 스코프 안에서만 참조 가능
- var 로 선언한 변수는 블록 스코프를 무시하고 스코프 밖에서도 접근 가능
- var 로 선언한 변수는 함수 스코프 만을 따름
- *그러나 블록 단위로 스코프를 구분했을 때, 훨씬 더 예측 가능한 코드를 작성할 수 있으므로 let 사용이 권장*

## 스코프와 관련해서 변수 선언시 주의점
### 전역 객체의 의해
- Window 객체는 브라우저에만 존재하는 객체
- 브라우저의 창을 의미하는 객체
- 별개로 전역 영역을 담고 있기도
=> 함수 선언식으로 함수를 선언하거나 var로 변수를 선언하면 window 객체에 속해짐
## 전역 변수는 최소화하기
- 전역변수 : 가장 바깥 스코프에 정의한 변수 -> 어디서든 접근 가능
- 전역 변수를 최소화 하면 의도하지 않은 로직에 의해 문제가 발생하는 것을 줄일 수 있음 (side effect 예방)
- 전역 변수를 var로 선언한다면 ?
--> 전역 변수는 어디서나 접근이 가능하고, var은 블록 스코프를 무시하고, 재선언과 재할당을 할수 있고..........
=> 브라우저의 내장 기능을 못하게 만들수도
## 선언없는 변수 할당 금지
- 선언없이 변수를 할당하면 해당 변수는 var로 선언한 전역변수처럼 취급
- 실수를 방지하기 위해 Strict Mode를 사용할 수 있음
-- Strict Mode는 브라우저가 보다 엄격하게 작동하도록 만들어줌
-- 선언 없는 변수 할당 -> 에러로 판단
-- 적용 -> js 파일 상단에 " 'use strict' " 라고 입력


--------------------
# 클로저 함수의 장점(활용)
- 1. 데이터를 보존할 수 있다.
-- 클로저 함수는 외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있다.
-- 클로저는 특정 데이터를 스코프 안에 가둬두고 계속 사용할 수 있게 -> 폐쇄성
- 2. 정보의 접근 제한 (캡슐화)
-- 클로저 모듈 패턴 사용 -> 객체에 담아 여러개의 함수 리턴 -> 정보의 접근 제한 -> 캡슐화
- 3. 모듈화 유리
-- 클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존 가능
-- 모듈화 : 함수의 재사용성을 극대화 -> 함수를 독립적인 부품의 형태로 분리
-- 클로저 -> 데이터와 메소드를 묶을 수 있음 -> 모듈화 유리

어라라, , 다못했음, , , , , 다음시간에 계속, , ,
